#include "pch.h"

#include "DxInputDevice.h"
#include "DxBackUpRendTarget.h"
#include "DxSurfaceTex.h"
#include "DxEnvironment.h"

#include "./DxEffectMan.h"

#include "DxPostProcess.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//#define _TEST
#define SHADER_ASSEM_MODE	// SHADER_HLSL_MODE

#if 0
//
// Generated by Microsoft (R) D3DX9 Shader Compiler 9.07.239.0000
//
//   fxc /T ps_1_1 /E PS /Fh Possasi.h Possasi.fx

sampler2D sampler_0;

float4 PS( float2 Tex : TEXCOORD0 ) : COLOR
{
    float4 t = tex2D( sampler_0, Tex );

    float4 Color2;
    Color2 = t * t;
    return Color2 * Color2;
}

technique tec0
{
    pass p0
    {
        PixelShader = compile ps_1_1 PS();
    }
}

//
//
// Parameters:
//
//   sampler2D sampler_0;
//
//
// Registers:
//
//   Name         Reg   Size
//   ------------ ----- ----
//   sampler_0    s0       1
//

    ps_1_1
    tex t0
    mul r0, t0, t0
    mul r0, r0, r0

// approximately 3 instruction slots used (1 texture, 2 arithmetic)
#endif

static const DWORD g_ps11_PS[] =
{
    0xffff0101, 0x0023fffe, 0x42415443, 0x0000001c, 0x00000053, 0xffff0101, 
    0x00000001, 0x0000001c, 0x00000100, 0x0000004c, 0x00000030, 0x00000003, 
    0x00000001, 0x0000003c, 0x00000000, 0x706d6173, 0x5f72656c, 0xabab0030, 
    0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x315f7370, 0x4d00315f, 
    0x6f726369, 0x74666f73, 0x29522820, 0x44334420, 0x53203958, 0x65646168, 
    0x6f432072, 0x6c69706d, 0x39207265, 0x2e37302e, 0x2e393332, 0x30303030, 
    0xababab00, 0x00000042, 0xb00f0000, 0x00000005, 0x800f0000, 0xb0e40000, 
    0xb0e40000, 0x00000005, 0x800f0000, 0x80e40000, 0x80e40000, 0x0000ffff
};

DxPostProcess& DxPostProcess::GetInstance()
{
	static DxPostProcess Instance;
	return Instance;
}

DxPostProcess::DxPostProcess() :
	m_bOptionEnable(TRUE),
	m_bProjectActive(FALSE),
	m_bDeviceEnable(TRUE),
	m_bEnable(FALSE),

	m_pSavedSB(NULL),
	m_pDrawSB(NULL),

	m_pPossasiEFF(NULL),
	m_pTechnique(NULL),
	m_pPossasiPS(NULL),

	m_pScreenVB(NULL),
	m_pModulateVB(NULL),
	m_pTexture(NULL),
	m_pSurface(NULL),
	m_pTexTEMP(NULL),
	m_pSufTEMP(NULL),

	m_nWidth(NULL),
	m_nHeight(NULL)
{
	for( DWORD i=0; i<10; ++i )
	{
		m_pBlurVB[i] = NULL;
	}
}

DxPostProcess::~DxPostProcess()
{
	SAFE_RELEASE( m_pPossasiEFF );
	SAFE_RELEASE( m_pPossasiPS );

	SAFE_RELEASE( m_pSavedSB );
	SAFE_RELEASE( m_pDrawSB );
}

void DxPostProcess::RestoreDeviceObjects ( LPDIRECT3DDEVICEQ pd3dDevice )
{
	HRESULT hr(S_OK);

	D3DCAPSQ d3dCaps;
	pd3dDevice->GetDeviceCaps ( &d3dCaps );
	
	if( DxEffectMan::GetInstance().GetUseSwShader() || d3dCaps.PixelShaderVersion < D3DPS_VERSION(1, 3) )
	{
		m_bDeviceEnable = FALSE;
		return;
	}

#ifdef SHADER_ASSEM_MODE
	SAFE_RELEASE( m_pPossasiPS );
	hr = pd3dDevice->CreatePixelShader( (DWORD*)g_ps11_PS, &m_pPossasiPS );
	if( FAILED(hr) )
	{
		CDebugSet::ToListView ( "Call Me(Sung-Hwan Han) - m_pPossasiPS Error" );
		return;
	}
#elif SHADER_HLSL_MODE
	// Note : Effect 파일을 읽어온다.
	SAFE_RELEASE( m_pPossasiEFF );
	hr = D3DXCreateEffectFromFile( pd3dDevice, "Possasi.fx", NULL, NULL, D3DXFX_NOT_CLONEABLE, NULL, &m_pPossasiEFF, NULL );
	if( FAILED( hr ) )
	{
		CDebugSet::ToLogFile( "Call Me(Sung-Hwan Han) - Possasi.fx Error" );
		return;
	}

	if( m_pPossasiEFF )
	{
		m_pTechnique	= m_pPossasiEFF->GetTechniqueByName( "tec0" );
	}
#endif

	// Note : VB를 생성한다.
	LPDIRECT3DSURFACEQ pBackBuffer;
	pd3dDevice->GetBackBuffer ( 0, 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer );

	D3DSURFACE_DESC		d3dsdBackBuffer;
    pBackBuffer->GetDesc( &d3dsdBackBuffer );
	
	UINT nWidthFULL(d3dsdBackBuffer.Width);
	UINT nHeightFULL(d3dsdBackBuffer.Height);
	m_nWidth = nWidthFULL/4;
	m_nHeight = nHeightFULL/4;

    pBackBuffer->Release();

	// Note : 뽀샤시를 저장할 텍스쳐를 만든다. 실패한다면 return;
	DxBackUpRendTarget sBackupTarget( pd3dDevice );
	{
		if( !CreateTexAndClear( pd3dDevice, m_nWidth, m_nHeight, m_pTexture, m_pSurface ) )
		{
			sBackupTarget.RestoreTarget( pd3dDevice );
			m_bDeviceEnable = FALSE;

			return;
		}
	}
	sBackupTarget.RestoreTarget( pd3dDevice );

	{
		SAFE_RELEASE( m_pScreenVB );
		pd3dDevice->CreateVertexBuffer( sizeof(VERTEXCOLORRHW)*4, 0, VERTEXCOLORRHW::FVF, D3DPOOL_MANAGED, &m_pScreenVB, NULL );

		VERTEXCOLORRHW* pVertices;
		m_pScreenVB->Lock( 0, 0, (VOID**)&pVertices, 0L );

		pVertices[0].vPos = D3DXVECTOR4( 0.f,						0.f,				1.f, 1.f );
		pVertices[1].vPos = D3DXVECTOR4( (float)nWidthFULL-0.5f,	0.f,				1.f, 1.f );
		pVertices[2].vPos = D3DXVECTOR4( 0.f,						(float)nHeightFULL-0.5f,	1.f, 1.f );
		pVertices[3].vPos = D3DXVECTOR4( (float)nWidthFULL-0.5f,	(float)nHeightFULL-0.5f,	1.f, 1.f );

		pVertices[0].dwColor = 0x4400000;
		pVertices[1].dwColor = 0x4400000;
		pVertices[2].dwColor = 0x4400000;
		pVertices[3].dwColor = 0x4400000;

		pVertices[0].vTex = D3DXVECTOR2( 0.f,	0.f );
		pVertices[1].vTex = D3DXVECTOR2( 1.f,	0.f );
		pVertices[2].vTex = D3DXVECTOR2( 0.f,	1.f );
		pVertices[3].vTex = D3DXVECTOR2( 1.f,	1.f );

		m_pScreenVB->Unlock();
	}

	{
		float fOffsetWidth = 0.5f/m_nWidth;
		float fOffsetHeight = 0.5f/m_nHeight;

		SAFE_RELEASE( m_pModulateVB );
		pd3dDevice->CreateVertexBuffer( sizeof(VERTEXRHWTEX2)*4, 0, VERTEXRHWTEX2::FVF, D3DPOOL_MANAGED, &m_pModulateVB, NULL );

		VERTEXRHWTEX2* pVertices;
		m_pModulateVB->Lock( 0, 0, (VOID**)&pVertices, 0L );

		pVertices[0].vPos = D3DXVECTOR4( 0.f,					0.f,		1.f, 1.f );
		pVertices[1].vPos = D3DXVECTOR4( (float)m_nWidth-0.5f,	0.f,		1.f, 1.f );
		pVertices[2].vPos = D3DXVECTOR4( 0.f,					(float)m_nHeight-0.5f,	1.f, 1.f );
		pVertices[3].vPos = D3DXVECTOR4( (float)m_nWidth-0.5f,	(float)m_nHeight-0.5f,	1.f, 1.f );

		pVertices[0].vTex1 = D3DXVECTOR2( 0.f,	0.f );
		pVertices[1].vTex1 = D3DXVECTOR2( 1.f,	0.f );
		pVertices[2].vTex1 = D3DXVECTOR2( 0.f,	1.f );
		pVertices[3].vTex1 = D3DXVECTOR2( 1.f,	1.f );

		pVertices[0].vTex2 = D3DXVECTOR2( 0.f,	0.f );
		pVertices[1].vTex2 = D3DXVECTOR2( 1.f,	0.f );
		pVertices[2].vTex2 = D3DXVECTOR2( 0.f,	1.f );
		pVertices[3].vTex2 = D3DXVECTOR2( 1.f,	1.f );

		m_pModulateVB->Unlock();
	}

	float fValue00(0.09f);
	float fValue01(0.18f);
	float fValue02(0.05f);

	float fValue03(0.09f);
	float fValue04(0.18f);
	float fValue05(0.00f);

	CreateBlurVB( pd3dDevice, 0, -2, 0, fValue00 );
	CreateBlurVB( pd3dDevice, 1, -1, 0, fValue01 );
	CreateBlurVB( pd3dDevice, 2, 0, 0, fValue02 );
	CreateBlurVB( pd3dDevice, 3, 1, 0, fValue01 );
	CreateBlurVB( pd3dDevice, 4, 2, 0, fValue00 );

	CreateBlurVB( pd3dDevice, 5, 0, -2, fValue03 );
	CreateBlurVB( pd3dDevice, 6, 0, -1, fValue04 );
	CreateBlurVB( pd3dDevice, 7, 0, 0, fValue05 );
	CreateBlurVB( pd3dDevice, 8, 0, 1, fValue04 );
	CreateBlurVB( pd3dDevice, 9, 0, 2, fValue03 );

	for( UINT which=0; which<2; which++ )
	{
		pd3dDevice->BeginStateBlock();

		pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,		FALSE );
		pd3dDevice->SetRenderState( D3DRS_LIGHTING,			FALSE );
		pd3dDevice->SetRenderState( D3DRS_ZENABLE,			FALSE );
		pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,		FALSE );
		pd3dDevice->SetRenderState( D3DRS_FOGENABLE,		FALSE );
		pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );

		pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE );

		if( which==0 )	pd3dDevice->EndStateBlock( &m_pSavedSB );
		else			pd3dDevice->EndStateBlock( &m_pDrawSB );
	}
}

void DxPostProcess::InvalidateDeviceObjects()
{
	SAFE_RELEASE( m_pPossasiPS );
	SAFE_RELEASE( m_pPossasiEFF );	

	SAFE_RELEASE( m_pScreenVB );
	SAFE_RELEASE( m_pModulateVB );
	for( DWORD i=0; i<10; ++i )
	{
		SAFE_RELEASE( m_pBlurVB[i] );
	}

	SAFE_RELEASE( m_pTexture );
	SAFE_RELEASE( m_pSurface );
	SAFE_RELEASE( m_pTexTEMP );
	SAFE_RELEASE( m_pSufTEMP );

	
	SAFE_RELEASE( m_pSavedSB );
	SAFE_RELEASE( m_pDrawSB );
}

void DxPostProcess::FrameMove()
{
	m_bEnable = FALSE;	// 초기화

	if( !DxSurfaceTex::GetInstance().m_pWaveTex )					return;
	if( !m_pSufTEMP )												return;	
	if( !m_bOptionEnable || !m_bProjectActive || !m_bDeviceEnable )	return;

	m_bEnable = TRUE;	// 활성화
}

void DxPostProcess::Render( LPDIRECT3DDEVICEQ pd3dDevice )
{
	if( !m_bEnable )	return;

#ifdef _TEST
	if( !ValueEDIT() )	return;	// Edit 할 때만 쓰인다.. 평소는 사용안함.
#endif

	DxEnvironment::GetInstance().SetRefractPlayON();	// 활성화

	m_pSavedSB->Capture();
	m_pDrawSB->Apply();	

	DxBackUpRendTarget sBackupTarget( pd3dDevice );

	// Note : 이미지를 강조를 시킨다.
#ifdef SHADER_ASSEM_MODE
	ImageModulateASSEM( pd3dDevice );
#elif SHADER_HLSL_MODE
	ImageModulateHLSL( pd3dDevice );
#endif

	pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );

	// Note : 이미지를 문지름. Width, Height
	pd3dDevice->SetIndices( NULL );
	ImageBlur( pd3dDevice );

	sBackupTarget.RestoreTarget( pd3dDevice );

	pd3dDevice->SetRenderState( D3DRS_SRCBLEND,		D3DBLEND_ONE );
	pd3dDevice->SetRenderState( D3DRS_DESTBLEND,	D3DBLEND_ONE );
	pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );

	pd3dDevice->SetFVF( VERTEXCOLORRHW::FVF );
	pd3dDevice->SetTexture( 0, m_pTexture );
	pd3dDevice->SetStreamSource( 0, m_pScreenVB, 0, sizeof(VERTEXCOLORRHW) );
	pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

	m_pSavedSB->Apply();

	// Note : 테스트용 
#ifdef _TEST
	pd3dDevice->SetRenderState( D3DRS_LIGHTING,		FALSE );
	pd3dDevice->SetRenderState( D3DRS_ZENABLE,		FALSE );
	pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,	FALSE );
	pd3dDevice->SetRenderState( D3DRS_FOGENABLE,	FALSE );

	pd3dDevice->SetFVF( VERTEXRHWTEX2::FVF );
	pd3dDevice->SetTexture( 0, m_pTexture );
	pd3dDevice->SetStreamSource( 0, m_pModulateVB, 0, sizeof(VERTEXRHWTEX2) );
	pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

	m_pSavedSB->Apply();
#endif
}

void DxPostProcess::ImageModulateHLSL( LPDIRECT3DDEVICEQ pd3dDevice )
{
	pd3dDevice->SetRenderTarget( 0, m_pSurface );
	pd3dDevice->SetDepthStencilSurface( NULL );
	pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,0), 1.0f, 0L );

	m_pPossasiEFF->SetTechnique( m_pTechnique );
	m_pPossasiEFF->Begin( NULL, 0 );

	m_pPossasiEFF->BeginPass(0);
	{
		pd3dDevice->SetTexture( 0, DxSurfaceTex::GetInstance().m_pWaveTex );

		pd3dDevice->SetFVF( VERTEXRHWTEX2::FVF );
		pd3dDevice->SetStreamSource( 0, m_pModulateVB, 0, sizeof(VERTEXRHWTEX2) );
		pd3dDevice->SetIndices( NULL );

		pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
	}
	m_pPossasiEFF->EndPass();

	m_pPossasiEFF->End();
}

void DxPostProcess::ImageModulateASSEM( LPDIRECT3DDEVICEQ pd3dDevice )
{
	pd3dDevice->SetRenderTarget( 0, m_pSurface );
	pd3dDevice->SetDepthStencilSurface( NULL );
	pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,0), 1.0f, 0L );

	pd3dDevice->SetPixelShader( m_pPossasiPS );
	{
		pd3dDevice->SetTexture( 0, DxSurfaceTex::GetInstance().m_pWaveTex );

		pd3dDevice->SetFVF( VERTEXRHWTEX2::FVF );
		pd3dDevice->SetStreamSource( 0, m_pModulateVB, 0, sizeof(VERTEXRHWTEX2) );
		pd3dDevice->SetIndices( NULL );

		pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
	}
	pd3dDevice->SetPixelShader( NULL );
}

void DxPostProcess::ImageBlur( LPDIRECT3DDEVICEQ pd3dDevice )
{
	pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE );

	pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_ONE );
	pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );
	{
		// Width
		pd3dDevice->SetRenderTarget( 0, m_pSufTEMP );
		pd3dDevice->SetDepthStencilSurface( NULL );
		pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,0), 1.0f, 0L );

		pd3dDevice->SetTexture( 0, m_pTexture );

		pd3dDevice->SetFVF( VERTEXCOLORRHW::FVF );
		pd3dDevice->SetStreamSource( 0, m_pBlurVB[0], 0, sizeof(VERTEXCOLORRHW) );
		pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
		pd3dDevice->SetStreamSource( 0, m_pBlurVB[1], 0, sizeof(VERTEXCOLORRHW) );
		pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
//		pd3dDevice->SetStreamSource( 0, m_pBlurVB[2], 0, sizeof(VERTEXCOLORRHW) );
//		pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
		pd3dDevice->SetStreamSource( 0, m_pBlurVB[3], 0, sizeof(VERTEXCOLORRHW) );
		pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
		pd3dDevice->SetStreamSource( 0, m_pBlurVB[4], 0, sizeof(VERTEXCOLORRHW) );
		pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

		// Height
		pd3dDevice->SetRenderTarget( 0, m_pSurface );
		pd3dDevice->SetDepthStencilSurface( NULL );
		pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,0), 1.0f, 0L );

		pd3dDevice->SetTexture( 0, m_pTexTEMP );

		pd3dDevice->SetStreamSource( 0, m_pBlurVB[5], 0, sizeof(VERTEXCOLORRHW) );
		pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
		pd3dDevice->SetStreamSource( 0, m_pBlurVB[6], 0, sizeof(VERTEXCOLORRHW) );
		pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
//		pd3dDevice->SetStreamSource( 0, m_pBlurVB[7], 0, sizeof(VERTEXCOLORRHW) );
//		pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
		pd3dDevice->SetStreamSource( 0, m_pBlurVB[8], 0, sizeof(VERTEXCOLORRHW) );
		pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
		pd3dDevice->SetStreamSource( 0, m_pBlurVB[9], 0, sizeof(VERTEXCOLORRHW) );
		pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
	}
}


BOOL DxPostProcess::CreateTexAndClear( LPDIRECT3DDEVICEQ pd3dDevice, DWORD dwWidth, DWORD dwHeight, 
									LPDIRECT3DTEXTUREQ&	pTex, LPDIRECT3DSURFACEQ& pSuf )
{
	HRESULT hr(S_OK);

	LPDIRECT3DSURFACEQ pBackBuffer;
	pd3dDevice->GetBackBuffer ( 0, 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer );

	D3DSURFACE_DESC		d3dsdBackBuffer;
    pBackBuffer->GetDesc( &d3dsdBackBuffer );
	D3DFORMAT emMainFormat(d3dsdBackBuffer.Format);
    pBackBuffer->Release();

	//	Note : 임시 텍스쳐 만들기 - 	( 안 될 경우 컬러 포멧을 바꾸어 준다. )
	D3DFORMAT emFormat(D3DFMT_X8R8G8B8);
	if( FAILED ( pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, D3DUSAGE_RENDERTARGET,			// 1. D3DFMT_X8R8G8B8
											emFormat, D3DPOOL_DEFAULT, &pTex, NULL ) ) )
	{
		emFormat = D3DFMT_A8R8G8B8;
		if( FAILED ( pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, D3DUSAGE_RENDERTARGET,		// 2. D3DFMT_A8R8G8B8
											emFormat, D3DPOOL_DEFAULT, &pTex, NULL ) ) )	
		{
			emFormat = emMainFormat;
			hr = pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, D3DUSAGE_RENDERTARGET,			// 3. 현재 Format
										emFormat, D3DPOOL_DEFAULT, &pTex, NULL );
			if( FAILED(hr) )	return FALSE;
		}
	}

	hr = pTex->GetSurfaceLevel( 0, &pSuf );
	if( FAILED(hr) )	return FALSE;

	pd3dDevice->SetRenderTarget( 0, pSuf );
	pd3dDevice->SetDepthStencilSurface( NULL );
	pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,0), 1.0f, 0L );

	// Note : 임시 텍스쳐.
	pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, D3DUSAGE_RENDERTARGET,	emFormat, D3DPOOL_DEFAULT, &m_pTexTEMP, NULL );
	hr = m_pTexTEMP->GetSurfaceLevel( 0, &m_pSufTEMP );
	if( FAILED(hr) )	return FALSE;

	pd3dDevice->SetRenderTarget( 0, m_pSufTEMP );
	pd3dDevice->SetDepthStencilSurface( NULL );
	pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,0), 1.0f, 0L );

	return TRUE;
}

void DxPostProcess::CreateBlurVB( LPDIRECT3DDEVICEQ pd3dDevice, UINT i, float x, float y, float fAlpha )
{
	DWORD dwColor = (DWORD)(255.f*fAlpha);
	dwColor = (0xff<<24) + (dwColor<<16) + (dwColor<<8) + dwColor;

	float fOffsetWidth = ((float)x+0.5f)/m_nWidth;
	float fOffsetHeight = ((float)y+0.5f)/m_nHeight;

	SAFE_RELEASE( m_pBlurVB[i] );
	pd3dDevice->CreateVertexBuffer( sizeof(VERTEXCOLORRHW)*4, 0, VERTEXCOLORRHW::FVF, D3DPOOL_MANAGED, &m_pBlurVB[i], NULL );

	VERTEXCOLORRHW* pVertices(NULL);
	m_pBlurVB[i]->Lock( 0, 0, (VOID**)&pVertices, 0L );

	pVertices[0].vPos = D3DXVECTOR4( 0.f,					0.f,	1.f, 1.f );
	pVertices[1].vPos = D3DXVECTOR4( (float)m_nWidth-0.5f,	0.f,	1.f, 1.f );
	pVertices[2].vPos = D3DXVECTOR4( 0.f,					(float)m_nHeight-0.5f,	1.f, 1.f );
	pVertices[3].vPos = D3DXVECTOR4( (float)m_nWidth-0.5f,	(float)m_nHeight-0.5f,	1.f, 1.f );

	pVertices[0].dwColor = dwColor;
	pVertices[1].dwColor = dwColor;
	pVertices[2].dwColor = dwColor;
	pVertices[3].dwColor = dwColor;

	pVertices[0].vTex = D3DXVECTOR2( 0.f,	0.f );
	pVertices[1].vTex = D3DXVECTOR2( 1.f,	0.f );
	pVertices[2].vTex = D3DXVECTOR2( 0.f,	1.f );
	pVertices[3].vTex = D3DXVECTOR2( 1.f,	1.f );

	m_pBlurVB[i]->Unlock();
}

BOOL DxPostProcess::ValueEDIT()
{
	static BOOL bUse(TRUE);
	static float fValue(0.1f);
	static float fValue00(0.09f);
	static float fValue01(0.20f);
	static float fValue02(0.00f);
	static float fValue03(0.09f);
	static float fValue04(0.20f);
	static float fValue05(0.00f);
	DWORD dwColor(0L);

	if( DxInputDevice::GetInstance().GetKeyState(DIK_P)&DXKEY_DOWN )	bUse = (bUse) ? FALSE: TRUE;

	if( DxInputDevice::GetInstance().GetKeyState(DIK_S)&DXKEY_DOWN )	fValue00 += 0.01f;
	if( DxInputDevice::GetInstance().GetKeyState(DIK_X)&DXKEY_DOWN )	fValue00 -= 0.01f;
	if( DxInputDevice::GetInstance().GetKeyState(DIK_D)&DXKEY_DOWN )	fValue01 += 0.01f;
	if( DxInputDevice::GetInstance().GetKeyState(DIK_C)&DXKEY_DOWN )	fValue01 -= 0.01f;
	if( DxInputDevice::GetInstance().GetKeyState(DIK_F)&DXKEY_DOWN )	fValue02 += 0.01f;
	if( DxInputDevice::GetInstance().GetKeyState(DIK_V)&DXKEY_DOWN )	fValue02 -= 0.01f;

	if( DxInputDevice::GetInstance().GetKeyState(DIK_G)&DXKEY_DOWN )	fValue03 += 0.01f;
	if( DxInputDevice::GetInstance().GetKeyState(DIK_B)&DXKEY_DOWN )	fValue03 -= 0.01f;
	if( DxInputDevice::GetInstance().GetKeyState(DIK_H)&DXKEY_DOWN )	fValue04 += 0.01f;
	if( DxInputDevice::GetInstance().GetKeyState(DIK_N)&DXKEY_DOWN )	fValue04 -= 0.01f;
	if( DxInputDevice::GetInstance().GetKeyState(DIK_J)&DXKEY_DOWN )	fValue05 += 0.01f;
	if( DxInputDevice::GetInstance().GetKeyState(DIK_M)&DXKEY_DOWN )	fValue05 -= 0.01f;

	for( DWORD i=0; i<10; i++ )
	{
		switch( i )
		{
		case 0:
		case 4:
			fValue = fValue00;
			break;
		case 1:
		case 3:
			fValue = fValue01;
			break;
		case 2:
			fValue = fValue02;
			break;
		case 5:
		case 9:
			fValue = fValue03;
			break;
		case 6:
		case 8:
			fValue = fValue04;
			break;
		case 7:
			fValue = fValue05;
			break;
		}

		if( !bUse )	fValue = 0.f;

		VERTEXCOLORRHW* pVertices(NULL);
		m_pBlurVB[i]->Lock( 0, 0, (VOID**)&pVertices, 0L );

		dwColor = (DWORD)(255.f*fValue);
		dwColor = (0xff<<24) + (dwColor<<16) + (dwColor<<8) + dwColor;
		pVertices[0].dwColor = dwColor;
		pVertices[1].dwColor = dwColor;
		pVertices[2].dwColor = dwColor;
		pVertices[3].dwColor = dwColor;

		m_pBlurVB[i]->Unlock();
	}

	CDebugSet::ToView( 4, "Possasi	: %d", (int)bUse );
	CDebugSet::ToView( 5, "Width 0	: %f", fValue00 );
	CDebugSet::ToView( 6, "Width 1	: %f", fValue01 );
	CDebugSet::ToView( 7, "Width 2	: %f", fValue02 );
	CDebugSet::ToView( 8, "Height 0 : %f", fValue03 );
	CDebugSet::ToView( 9, "Height 0 : %f", fValue04 );
	CDebugSet::ToView( 10, "Height 0 : %f", fValue05 );



	static float fValue111(0.9f);

	if( DxInputDevice::GetInstance().GetKeyState(DIK_U)&DXKEY_DOWN )	fValue111 += 0.01f;
	if( DxInputDevice::GetInstance().GetKeyState(DIK_Y)&DXKEY_DOWN )	fValue111 -= 0.01f;

	VERTEXCOLORRHW* pVertices(NULL);
	m_pScreenVB->Lock( 0, 0, (VOID**)&pVertices, 0L );

	dwColor = (DWORD)(255.f*fValue111);
	dwColor = (dwColor<<24);
	pVertices[0].dwColor = dwColor;
	pVertices[1].dwColor = dwColor;
	pVertices[2].dwColor = dwColor;
	pVertices[3].dwColor = dwColor;

	m_pScreenVB->Unlock();

	CDebugSet::ToView( 11, "Blur : %f", fValue111 );

	return bUse;
}
